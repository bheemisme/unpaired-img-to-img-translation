import torch
import torch.nn as nn
from utils import Config
from networks import Generator, Discriminator

def cycle_consistency_loss(
    real_x: torch.Tensor,
    real_y: torch.Tensor,
    generator_x_to_y: nn.Module,
    generator_y_to_x: nn.Module
) -> torch.Tensor:
    """
    Compute cycle consistency loss for CycleGAN.

    Args:
        real_x (torch.Tensor): Real images from domain X (Monet), shape [batch_size, 3, 256, 256].
        real_y (torch.Tensor): Real images from domain Y (photo), shape [batch_size, 3, 256, 256].
        generator_x_to_y (nn.Module): Generator mapping X → Y (Monet to photo).
        generator_y_to_x (nn.Module): Generator mapping Y → X (photo to Monet).

    Returns:
        torch.Tensor: Cycle consistency loss (scalar).
    """
    # Generate fake images
    fake_y = generator_x_to_y(real_x)  # X → Y
    fake_x = generator_y_to_x(real_y)  # Y → X

    # Reconstruct original images
    reconstructed_x = generator_y_to_x(fake_y)  # X → Y → X
    reconstructed_y = generator_x_to_y(fake_x)  # Y → X → Y

    # Compute L1 loss for cycle consistency
    cycle_loss_x = torch.mean(torch.abs(reconstructed_x - real_x))
    cycle_loss_y = torch.mean(torch.abs(reconstructed_y - real_y))

    # Combine and weight by lambda_cycle
    total_cycle_loss = Config.lambda_cycle * (cycle_loss_x + cycle_loss_y)
    return total_cycle_loss


def adversarial_loss(
    real: torch.Tensor,
    fake: torch.Tensor,
    discriminator: nn.Module,
    is_discriminator: bool = True
) -> torch.Tensor:
    """
    Compute adversarial loss for CycleGAN using LSGAN (MSE loss) for PatchGAN output.

    Args:
        real (torch.Tensor): Real images from a domain, shape [batch_size, 3, 256, 256].
        fake (torch.Tensor): Fake images generated by a generator, shape [batch_size, 3, 256, 256].
        discriminator (nn.Module): Discriminator for the corresponding domain.
        is_discriminator (bool): If True, compute loss for discriminator; else, for generator.

    Returns:
        torch.Tensor: Adversarial loss (scalar).
    """
    # Get discriminator outputs (patch maps: [batch_size, 1, 30, 30])
    real_pred = discriminator(real)
    fake_pred = discriminator(fake)

    if is_discriminator:
        # Discriminator loss: real patches target 1, fake patches target 0
        real_loss = torch.mean((real_pred - 1.0) ** 2)
        fake_loss = torch.mean(fake_pred ** 2)
        return 0.5 * (real_loss + fake_loss)
    else:
        # Generator loss: fake patches target 1
        return torch.mean((fake_pred - 1.0) ** 2)

def identity_loss(
    real_x: torch.Tensor,
    real_y: torch.Tensor,
    generator_x_to_y: nn.Module,
    generator_y_to_x: nn.Module
) -> torch.Tensor:
    """
    Compute identity loss for CycleGAN.

    Args:
        real_x (torch.Tensor): Real images from domain X (Monet), shape [batch_size, 3, 256, 256].
        real_y (torch.Tensor): Real images from domain Y (photo), shape [batch_size, 3, 256, 256].
        generator_x_to_y (nn.Module): Generator mapping X → Y (Monet to photo).
        generator_y_to_x (nn.Module): Generator mapping Y → X (photo to Monet).

    Returns:
        torch.Tensor: Identity loss (scalar).
    """
    # Compute identity mappings: G(y) ≈ y, F(x) ≈ x
    identity_y = generator_x_to_y(real_y)  # G: Y → Y
    identity_x = generator_y_to_x(real_x)  # F: X → X

    # Compute L1 loss for identity
    identity_loss_y = torch.mean(torch.abs(identity_y - real_y))
    identity_loss_x = torch.mean(torch.abs(identity_x - real_x))

    # Combine and weight by lambda_identity
    total_identity_loss = Config.lambda_identity * (identity_loss_x + identity_loss_y)
    return total_identity_loss


if __name__ == "__main__":
    
    batch_size = Config.batch_size
    channels = Config.img_channels
    img_size = Config.img_size
    device = Config.device
    
    # Create sample inputs and models
    real_x = torch.randn(batch_size, channels, img_size, img_size).to(device)
    real_y = torch.randn(batch_size, channels, img_size, img_size).to(device)
    generator_x_to_y = Generator().to(device)
    generator_y_to_x = Generator().to(device)
    discriminator = Discriminator().to(device)
    discriminator.apply(Discriminator.init_weights)

    # Test adversarial loss
    fake_y = generator_x_to_y(real_x)
    disc_loss = adversarial_loss(real_y, fake_y, discriminator, is_discriminator=True)
    gen_loss = adversarial_loss(real_y, fake_y, discriminator, is_discriminator=False)
    print(f"Discriminator Loss: {disc_loss.item()}")
    print(f"Generator Loss: {gen_loss.item()}")
    
    # Test cycle consistency loss
    cycle_loss = cycle_consistency_loss(real_x, real_y, generator_x_to_y, generator_y_to_x)
    print(f"Cycle Consistency Loss: {cycle_loss.item()}")

    # Test identity loss
    id_loss = identity_loss(real_x, real_y, generator_x_to_y, generator_y_to_x)
    print(f"Identity Loss: {id_loss.item()}")
